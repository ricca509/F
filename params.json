{"name":"F","tagline":"A small, modular library that helps writing structured, reusable, testable and namespaced javascript code. It also provides DOM and utility helpers.","body":"## F: a library to namespace, structure and speed up your javascript code\r\n\r\n[![Build Status](https://travis-ci.org/ricca509/F.png?branch=master)](https://travis-ci.org/ricca509/F)\r\n\r\nA small    library\tthat mainly targets\tall\tthose multiple pages (server side MVC) projects\tthat usually donâ€™t have a structured javascript code due to the fact that\tmost of the\tjob\tis done on the server but eventually end up with a load of unstructured, spaghetti code.\r\n\r\nThe F library is built with the purpose of working on multiple page applications easier and faster, giving a structure to the code and allowing the developer to write structured, namespaced, testable code quickly and easily.\r\n\r\n### Dependencies\r\n* Lo-Dash\r\n* jQuery (only if you use the *Dom* module)\r\n\r\n### Install it\r\n\r\n#### with Bower\r\n```\r\n$ bower install F\r\n```\r\n#### or grab the latest release\r\nhttps://github.com/ricca509/F/releases\r\n\r\n## Core module\r\n\r\nBasic usage is the best way to show the library's features.\r\n\r\n### Include it in your page\r\n\r\nIn your HTML page, include the dependencies and the library:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"/libs/jquery.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"/libs/lodash.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"/libs/F.min.js\"></script>\r\n```\r\n\r\nIf you use AMD with RequireJS:\r\n\r\n```javascript\r\ndefine(['./path/to/F'], function (F) {\r\n    F.defineModule({});\r\n    ...\r\n});\r\n// or\r\nrequire(['./path/to/F'], function (F) {\r\n    F.defineModule({});\r\n    ...\r\n});\r\n```\r\n\r\nIf you use Browserify:\r\n\r\n```javascript\r\nvar F = require('./path/to/F');\r\nF.defineModule({});\r\n...\r\n```\r\n\r\n### Create namespaced objects (`F.defineModule`)\r\n**Method signature:**\r\n```javascript\r\nF.defineModule(namespaceToCreate, object, afterDefinedCallback);\r\n```\r\n\r\n**Create a namespace** from a string:\r\n\r\n```javascript\r\nF.defineModule('F.Tests.Module1');\r\n```\r\nEvery object (or module) created with the F library has a `type` property. If you do not specify one, the library add `default` for you:\r\n\r\n```javascript\r\n> F.Tests.Module1;\r\nObject {type: \"default\"}\r\n```\r\nYou can pass an **object** to define the structure of your module:\r\n\r\n```javascript\r\nF.defineModule('F.Tests.testObject', {\r\n    defaults: {\r\n        numArticles: 5\r\n    },\r\n    handleLink: function (ev) {\r\n        ev.preventDefault();\r\n    },\r\n    test: function() {\r\n        console.log('Test called');\r\n    },\r\n    init: function() {\r\n        this.test();\r\n        this.a = 10;\r\n    }\r\n});\r\n\r\n// In the console:\r\n> F.Tests.testObject\r\nObject {defaults: Object, handleLink: function, test: function, init: function, type: \"default\"}\r\n```\r\nor a **function**:\r\n\r\n```javascript\r\nF.defineModule('F.Tests.testFunction', function() {\r\n    var a, b;\r\n    var c = function() {\r\n        // stuff\r\n    }\r\n    \r\n    return {\r\n        doSomething: c\r\n    };\r\n});\r\n\r\n// In the console:\r\n> F.Tests.testFunction\r\nfunction () {\r\n    var a, b;\r\n    var c = function() {\r\n        // stuff\r\n    }\r\n    \r\n    return {\r\n        doSomething: c\r\n    };\r\n}\r\n```\r\n\r\nor a **variable**:\r\n\r\n```javascript\r\nF.defineModule('F.Tests.testVariable', 'variableValue');\r\n\r\n// In the console:\r\n> F.Tests.testVariable\r\n\"variableValue\"\r\n```\r\n### Extend your modules (`F.extendModule`)\r\nYou can extend your modules (only object modules at the moment). This allows you to create reusable modules and make you code simpler, easier to test and debug.\r\n\r\n**Method signature:**\r\n```javascript\r\nF.extendModule(moduleToExtend, moduleThatExtends, extendedModuleNamespace, afterExtendedCallback)\r\n```\r\n**Extend a module with an object:**\r\n```javascript\r\n// Define an object module \"F.objA\"\r\nF.defineModule('F.objA', {\r\n    one: 'string',\r\n    two: function() {\r\n        return 'function two'\r\n    }\r\n});\r\n\r\n// Create a new module \"F.newExtendedModule\"\r\n// extending \"F.objA\" with a plain object\r\nF.extendModule('F.objA', {\r\n    three: 5,\r\n    four: true\r\n}, 'F.newExtendedModule');\r\n```\r\n\r\n**Extend a plain object with another one:**\r\n```javascript\r\n// Create a new module \"F.newExtendedModule\"\r\n// from two plain objects \r\n// (the extended object will have the \"type\" property set to \"default\")\r\nF.extendModule({\r\n        a: '1',\r\n        b: '2'\r\n    }, {\r\n        c: '3',\r\n        d: '4'\r\n}, 'F.newExtendedModule');\r\n```\r\n\r\n### Create instances of your objects (`F.createInstance`)\r\n\r\nOnce you have created a **module**, you can create **instances** of it, similar to the *Class > Object* relationship:\r\n\r\n**Method signature:**\r\n```javascript\r\nF.createInstance(module, opts, onBeforeCreate, onAfterCreate)\r\n```\r\n\r\nExample:\r\n```javascript\r\nvar instance = F.createInstance(F.Tests.TestModule);\r\n```\r\n\r\nYou can create instances of an existing module passing the string representing the namespace or the object itself\r\n\r\n```javascript\r\nvar instance = F.createInstance('F.Tests.TestModule');\r\n```\r\nYou can **extend the standard instance** of a module with additional configuration. Your configuration will be applied to your instance, without modifying the default definition of the module:\r\n\r\n```javascript\r\nvar instance = F.createInstance(F.Tests.UIModule, {\r\n    el: 'body'\r\n});\r\n```\r\nEvery time you create an instance of a module, the F library calls `onBefore` and `onAfter` callbacks if provided. The complete call for the `createInstance` function is the following:\r\n\r\n```javascript\r\nvar instance = F.createInstance(moduleToCreateInstanceFrom, extendObject, onBefore, onAfter);\r\n```\r\n\r\n#### The `init` function\r\nIf you define a `init` function within your module, it **will run as soon as you create an instance** of the module via the `F.createInstance`.\r\n\r\nThe *core F library* is pretty much this: a simple way to create namespaces that contain variables, object or functions and create instances of them. This helps maintaining a **structured, globals-free code**.\r\n\r\nThe power of the library is the fact that, by using a generic modular system, you can define your own module type and let the library call it for you. The next section explore the modules echosystem.\r\n\r\n### Helpers functions\r\nWhile the core of the library will remain small by purpose, there are \"addons\" that extends it. The following functions are available:\r\n\r\n**Core**\r\n* `F.defineModule(namespaceToCreate, object, afterDefinedCallback);`\r\n* `F.extendModule(moduleToExtend, moduleThatExtends, extendedModuleNamespace, afterExtendedCallback)`\r\n* `F.createInstance(module, opts, onBeforeCreate, onAfterCreate)`\r\n\r\n**String addon `F.str`**\r\n* `F.str.trimStart(str)`\r\n* `F.str.trimEnd(str)`\r\n* `F.str.trim(str)`\r\n\r\n**Events: Publisher/Subscriber addon `F.evt`**\r\n* `F.evt.on(topic, callback)`\r\n* `F.evt.off(topic, index)`\r\n* `F.evt.trigger(topic, args)`\r\n\r\n## Addons\r\n\r\n### Events Publisher/Subscriber `F.evt`\r\nAn events addon can be found under `F.evt`.\r\n\r\n#### The `on` method\r\nYou can subscribe to an event with the `on` method. You have to pass the event name and a callback.\r\n\r\n`F.evt.on(topic, callback)`\r\n\r\nreturns an index, that can be used to unscribe from the event.\r\n\r\n```javascript\r\nvar key = F.evt.on('test', function(args) {\r\n    console.log('Test ' + args);\r\n});\r\n```\r\n\r\n#### The `trigger` method\r\nYou can trigger an event with the `trigger` method, it accepts the name of the event and the arguments you want to publish with the event.\r\n\r\n```javascript\r\nvar key = F.evt.on('test', function(args) {\r\n    console.log('Test ' + args);\r\n});\r\n\r\nF.evt.trigger('test', ['one', 'two']);\r\n```\r\n\r\n#### The `off` method\r\nYou can unscribe from an event using the event name and the `index` returned by the `on` method.\r\n\r\n`F.evt.off(topic, index)`\r\n\r\n```javascript\r\nvar key = F.evt.on('test', function(args) {\r\n    console.log('Test ' + args);\r\n});\r\n\r\nF.evt.trigger('test', ['one', 'two']);\r\n\r\nF.evt.off('test', key);\r\n```\r\n\r\n## The modules ecosystem\r\n\r\n### The *dom* module (`type: 'dom'`)\r\n\r\nThe *dom* module makes it easy to work with DOM related stuff. It offers:\r\n\r\n* declarative event binding\r\n* auto scoping to a root element\r\n* selectors caching (UI declaration)\r\n* jQuery shortcuts\r\n\r\nMake sure to define the right `type` property when you define your module if you want to use the features of the *dom* module:\r\n\r\n```javascript\r\nF.defineModule('F.Tests.DomModule', {\r\n    type: 'dom'\r\n});\r\n```\r\n#### The `el` element\r\nAs in Backbone.js views, the `el` element represent the root element of the module: every operation within the module will be scoped to this element. If you don't declare any 'el', the module will use 'body'.\r\n\r\n#### The `$el` element\r\nThe module automatically creates a `$el` element, which is a jQuery wrapped element of the `el` element. If you declare both `$el` and `el`, the `$el` will win and `el` will be set to `$el.selector`.\r\n\r\n#### The `this.$()` function\r\nEvery operation within the module has to be done in the scope of the `el` element. To achieve this, you can use the `this.$()` function. This is the same as using `this.$el.find()` or `$(el).find()`.\r\n\r\n#### The `UI` object\r\nIf you want to have a 'shortcut' to often used elements and want the module to cache them for you, you have to use the `UI` object. It is pretty straightforward:\r\n\r\n```javascript\r\nUI: {\r\n    articleList: '#article-list',\r\n    moreButton: '#more-button',\r\n    outside: '#outside'\r\n}\r\n```\r\nThe key is the shortcut name, the value is the jQuery CSS selector. You'll be able to access the elements with `this.UI.name`.\r\nFor every key in the UI object, as soon as you'll create an instance of the object you will get the jQuery oject associated to that selector. You can access the jQuery object by preceding the name with a $:\r\n\r\n(string selector) `this.UI.articleList` -> (jQuery object) `this.UI.$articleList`\r\n\r\n#### The `events` object\r\nThe declarative event binding is achieved by using the `events` object:\r\n\r\n```javascript\r\nevents: {\r\n    'click': {\r\n        'ul#list>li.list span': 'handleLink'\r\n    } \r\n}\r\n```\r\nThe properties of the \"events\" object are always the event (or events) name (`click`, in this case). \r\nThe value of each property is an object itself. The left side contains the selector as key.\r\nOn the right side, we have the name of the handler function as value, that has to be declared inside the module.\r\n\r\n**Selectors type and syntax**\r\n- **Normal** jQuery CSS selector, **scoped** to the el element: just write the plain jQuery selector.\r\n\r\n```javascript\r\nevents: {\r\n    'click': {\r\n    '   ul#list>li.list span': 'handleLink'\r\n    }\r\n}\r\n```\r\n- **Cached** element, defined in the UI object: use the normal object sintax.\r\n\r\n```javascript\r\nevents: {\r\n    'click': {\r\n        'this.UI.link1': 'handleLink'\r\n    } \r\n}\r\n```\r\n- **External** element, access elements outside el, 'document' and window included: prepend the `@` symbol before the CSS selector (or `@window`, `@document`)\r\n\r\n```javascript\r\nevents: {\r\n    'click': {\r\n        '@#outside': 'handleLink',\r\n        '@document': 'handleLink'\r\n    }\r\n}\r\n```\r\n\r\n### Complete example\r\nThe complete list of properties for the *domModule* follows:\r\n\r\n```javascript\r\nF.defineModule('F.Tests.DomModule1', {\r\n    // Always define the type property correctly\r\n    type: 'dom',\r\n    // Define the root element of your module.\r\n    // The module will have the scope restricted to this element\r\n    // for increased security\r\n    // The module will create a $el variable with the jQuery element\r\n    // representing your root element\r\n    el: '#test',\r\n    // Define the jQuery elements that you want to cache by declaring their\r\n    // selectors here, the module will create variables inside this object\r\n    // with a $ prefix and a jQuery object for you\r\n    // e.g. (articleList -> $articleList)\r\n    UI: {\r\n        articleList: '#article-list',\r\n        moreButton: '#more-button',\r\n        outside: '#outside'\r\n    },\r\n    // Declarative event binding\r\n    events: {\r\n        'click': {\r\n            'ul#list>li.list span, this.UI.moreButton, @#outside': 'handleLink'\r\n        }\r\n    },\r\n    handleLink: function (ev) {\r\n        ev.preventDefault();\r\n    },\r\n    test: function() {\r\n        console.log('Test called');\r\n    },\r\n    // The init function, if present, is automatically called by the\r\n    // createInstance function for you. Write here the code that you want to \r\n    // run when the module is instantiated\r\n    init: function() {\r\n    }\r\n});\r\n```\r\n\r\n## Writing a module\r\nDefining a new module is easy and make it possible to extend the *F core*, which is small by intention.\r\n\r\n### Pick up a name\r\n\r\nThe first step is to pick up a name for the module. Let's assume we want to create the `fooModule`. When defining a module of this type, we will have to define the `type` property to be `foo`:\r\n\r\n```javascript\r\nF.defineModule('F.Tests.fooModule1', {\r\n    type: 'foo',\r\n    ...\r\n}\r\n```\r\nThe *F core* library, reading the `type` property of the module (`test`), will search under `F.plugins` an object called `fooModule` (`F.plugins.fooModule`).\r\n\r\n### Define the `initModule` function\r\n\r\nThe `F.plugins.fooModule` will have to expose the `initModule` function. It will be passed an instance of the object, and will have to return it (after having modified it).\r\n\r\nAn example of an `initModule` defined for our `F.plugins.fooModule` function is as follows:\r\n\r\n```javascript\r\n(function(F) {\r\n    'use strict';\r\n    var _module;\r\n    \r\n    var initModule = function (module) {\r\n        _module = module;\r\n        return _module;\r\n    };\r\n\r\n    F.plugins.defaultModule = {\r\n        initModule: initModule\r\n    };\r\n}(F));\r\n```\r\n\r\nYou can find an example under ` /src/plugins/F.plugins.defaultModule.js`\r\n\r\n### Create a plugin file for the module and include it in your page\r\nThe best place for the `F.plugins.fooModule` is in a file named `F.plugins.fooModule.js`. \r\n\r\nBe sure to include it after the main F include.\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"/libs/jquery.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"/libs/underscore-min.js\"></script>\r\n<script type=\"text/javascript\" src=\"/libs/F.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"/libs/F.plugins.fooModule.js\"></script>\r\n```\r\n\r\n### That's it!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}